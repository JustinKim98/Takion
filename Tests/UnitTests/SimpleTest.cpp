#include <Test.h>
#include <gtest/gtest.h>

/**
 * This source file contains several examples for creating executable graphs
 * Example1, Example2, Example3 contains different shapes of graphs
 *
 * There are 3 class templates that can be used
 * These class templates will provide operations that can be executed after
 *compilation of the graph
 *
 * 1. generate
 * >member functions of this class template will generate tensors
 *
 * 2. operate
 * >member functions of this class will receive tensors from other operations,
 *and return the result as a single tensor
 *
 * 3. final
 * >member functions of this class will receive tensors from other operations,
 *and will not return any. every tensor should be connected to this final
 *operation to be executed
 *
 *
 * There are several rules that must be kept
 * 1. Tensors must be generated by methods of 'generate' template class
 * 2. Every tensor should be connected to 'final' operation (otherwise, they
 *won't be executed)
 */

using namespace cubby_dnn;

std::vector<operation_info> Example1()
{
    /// file stream class template is used for streaming data inside external
    /// files
    file_stream<int> file_stream;

    /// operation that streams file data into tensor in shape (2,2,1)
    auto input_tensor1 =
        generate<int>::placeholder(tensor_shape(2, 2, 1), file_stream);

    /// operation that returns tensor variable in shape (2, 2, 1), and mark it
    /// trainable(non- constant)
    auto input_tensor2 =
        generate<int>::variable(tensor_shape(2, 2, 1), true);  // 2

    /// operation that multiplies two tensors and returns tensor to contain the
    /// result
    auto multiplied_tensor1 =
        operate<int>::mat_mul(input_tensor2, input_tensor1);  // 3

    final<int>::wrapper(multiplied_tensor1);  // 4

    /// operation that multiplies two tensors and returns tensor to contain the
    /// result
    auto multiplied_tensor2 =
        operate<int>::mat_mul(input_tensor2, input_tensor1);  // 5

    /// operation that adds two tensors and returns tensor to contain the result
    auto added_tensor1 =
        operate<int>::mad_add(input_tensor1, input_tensor2);  // 6

    /// operation that calculates dot-product of given tensor and multiplier and
    /// returns tensor to contain the result
    auto dot_operated_tensor1 = operate<int>::mat_dot(added_tensor1, 5);  // 7

    /// operation that reshapes given tensor to another shape (total size of
    /// given tensor, and return shape must match)
    auto reshaped_tensor1 = operate<int>::reshape(dot_operated_tensor1,
                                                  tensor_shape(1, 2, 2));  // 8

    /// operation that receives tensor and marks given tensor has no more
    /// further operation (end of the graph)
    final<int>::wrapper(multiplied_tensor1);  // 9

    /// operation that receives tensor and marks given tensor has no more
    /// further operation (end of the graph)
    final<int>::wrapper(multiplied_tensor2);  // 10

    /// operation that receives tensor and marks given tensor has no more
    /// further operation (end of the graph)
    final<int>::wrapper(reshaped_tensor1);  // 11

    ///prints information of operations in generated graph
    operation_management<int>::print_operation_info();

    ///creates adjacency matrix for graph
    operation_management<int>::create_adj();

    ///prints previously generated adjacency matrix for graph
    adj_management<int>::print_adj();

    return operation_management<int>::get_operation_info();
}

std::vector<operation_info> Example2()
{
    file_stream<int> file_stream;
    auto input_tensor1 =
        generate<int>::placeholder(tensor_shape(2, 4, 3), file_stream);  // 1

    auto input_tensor2 =
        generate<int>::variable(tensor_shape(4, 2, 3), true);  // 2

    auto multiplied_tensor1 =
        operate<int>::mat_mul(input_tensor2, input_tensor1);  // 3
    final<int>::wrapper(multiplied_tensor1);                  // 4

    operation_management<float>::print_operation_info();
    return operation_management<int>::get_operation_info();
}

std::vector<operation_info> Example3()
{
    file_stream<float> file_stream;
    auto input_tensor1 =
        generate<float>::placeholder(tensor_shape(5, 4, 3), file_stream);
    auto input_tensor2 = generate<float>::variable(tensor_shape(4, 5, 3), true);

    auto input_tensor3 = generate<float>::variable(tensor_shape(5, 5, 3), true);

    auto multiplied_tensor1 =
        operate<float>::mat_mul(input_tensor1, input_tensor2);  // shape: 5,5,3

    auto multiplied_tensor2 = operate<float>::mat_mul(
        multiplied_tensor1, input_tensor3);  // shape: 5,5,3

    auto added_tensor1 = operate<float>::mad_add(
        multiplied_tensor2, input_tensor3);  // shape: 5,5,3

    auto reshaped_tensor1 =
        operate<float>::reshape(added_tensor1, tensor_shape(75, 1, 1));

    final<float>::wrapper(reshaped_tensor1);

    operation_management<float>::print_operation_info();
    return operation_management<float>::get_operation_info();
}

TEST(SimpleTest, Add)
{
    EXPECT_EQ(5, Add(2, 3));
    std::cout << "called Test" << std::endl;
}

TEST(Test1, Example1)
{
    std::vector<cubby_dnn::operation_info> ans{
        operation_info{ 0, 0, 3, "placeholder" },
        operation_info{ 1, 0, 3, "weight" },
        operation_info{ 2, 2, 2, "mat_mul" },
        operation_info{ 3, 1, 0, "wrapper" },
        operation_info{ 4, 2, 1, "mat_mul" },
        operation_info{ 5, 2, 1, "mat_add" },
        operation_info{ 6, 1, 1, "mat_dot" },
        operation_info{ 7, 1, 1, "reshape" },
        operation_info{ 8, 1, 0, "wrapper" },
        operation_info{ 9, 1, 0, "wrapper" },
        operation_info{ 10, 1, 0, "wrapper" }
    };

    EXPECT_EQ(ans, Example1());
}

TEST(Test2, Example2)
{
    std::vector<cubby_dnn::operation_info> ans{
        operation_info{ 0, 0, 1, "placeholder" },
        operation_info{ 1, 0, 1, "weight" },
        operation_info{ 2, 2, 1, "mat_mul" },
        operation_info{ 3, 1, 0, "wrapper" }
    };

    EXPECT_EQ(ans, Example2());
}

TEST(Test3, Example3)
{
    std::vector<cubby_dnn::operation_info> ans{
        operation_info{ 0, 0, 1, "placeholder" },
        operation_info{ 1, 0, 1, "weight" },
        operation_info{ 2, 0, 2, "weight" },
        operation_info{ 3, 2, 1, "mat_mul" },
        operation_info{ 4, 2, 1, "mat_mul" },
        operation_info{ 5, 2, 1, "mat_add" },
        operation_info{ 6, 1, 1, "reshape" },
        operation_info{ 7, 1, 0, "wrapper" }
    };

    EXPECT_EQ(ans, Example3());
}
